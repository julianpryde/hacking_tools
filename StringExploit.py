# pylint: disable=wildcard-import, unused-wildcard-import, missing-module-docstring
# pylint: disable=missing-class-docstring, missing-function-docstring, no-else-return
# pylint: disable=redefined-builtin

from pwn import *  # type: ignore[import]
from ExploitTools import ExploitTools
import ctypes

class IntSizeException(ValueError): ...

class StringExploit(ExploitTools):
    def __init__(self, image_base, exe, input_type=None, final_type=None):
        super().__init__(image_base, exe)
        self.gdbscript = 'b main'
        self.value_num = 0

        # default data type that input values will be initially converted into
        self.input_type = ctypes.c_int if input_type is None else input_type
        self.input_size =  ctypes.sizeof(self.input_type)

        # data type that the values will eventually be read as by the target program
        self.final_type = ctypes.c_int64 if self.register_size == 4 else ctypes.c_int32
        self.final_size = ctypes.sizeof(self.final_type)

    def mask_value(self, iteration: int, input_data_size: int, value) -> bytes:
        current_mask = 2 ** (8 * input_data_size * iteration) - 1
        previous_mask = 2 ** (8 * input_data_size * (iteration - 1)) - 1
        mask = current_mask - previous_mask
        masked_value = (value & mask).to_bytes(input_data_size, byteorder='big')
        print(f"masked_value: {masked_value}")
        return masked_value

    def send_number(self, value, local_input_size: int = None, local_final_size: int = None) -> None:
        """
        This method will split up an n-size input integer into an n / (2*x)-size int data type (e.g. 8-byte
        integer into a 4-byte C int). Any other data conversions will require overriding the method.
        """
        local_input_size = self.input_size if local_input_size is None else local_input_size
        local_final_size = self.final_size if local_final_size is None else local_final_size

        # value_bit_array = util.fiddling.bits(value)  # TODO make it work with floats as input types
        print(f"number: {hex(value)}")
        number_of_pieces = math.floor(local_final_size / local_input_size)
        for index in range(1, number_of_pieces + 1):
            self.send_value(self.mask_value(index, local_input_size, value))

    def pad_string(self, byte_string: bytes) -> bytes:
        if len(byte_string) % self.word_size != 0:
            null_terminators_to_add = \
                self.word_size * math.ceil(len(byte_string) / self.word_size) \
                - len(byte_string)
            byte_string += b'\x00' * null_terminators_to_add
            print(f"null_terminators_to_add: {null_terminators_to_add}")

        return byte_string

    def send_str(self, input_string: str) -> None:
        byte_string = input_string.encode()
        padded_string = self.pad_string(byte_string)
        little_endian_string = padded_string[::-1]
        print(f"len(byte_string): {len(little_endian_string)}")
        print(f"byte string: {little_endian_string!r}")
        self.send_bytes_by_word(little_endian_string)

    def start(self, gdbscript: str = 'b main', *a, **kw):
        return super().start(gdbscript, *a, **kw)

    def send_padding(self, registers: int) -> None:
        self.send_bytes_by_word(self.generate_padding(registers))

    def send_bytes_by_word(self, byte_string: bytes) -> None:
        for i in reversed(range(0, len(byte_string), 4)):
            self.send_value(byte_string[i:i + 4])

    #pylint: disable-next=unused-argument
    def send_value(self, word: bytes) -> None: ...

    def send_chain(self) -> None: ...

    def set_breakpoints(self) -> None: ...

    def prepare_for_payload(self) -> None: ...
